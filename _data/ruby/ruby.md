---

### **1. Fundamentos Avan√ßados do Ruby**

- Estruturas de Dados (Arrays, Hashes, Sets, Structs)
- Controle de Fluxo (loops, iterators, blocks, procs, lambdas)
- M√©todos e escopo (private, protected, public)
- M√©todos Singleton e Metaprograma√ß√£o
- Mixins e M√≥dulos (include, extend, prepend)
- Manipula√ß√£o de Strings e Express√µes Regulares
- Symbols vs Strings
- Gest√£o de Exce√ß√µes e Resili√™ncia (rescue, retry, ensure)
- Duck Typing e Polimorfismo

### **2. Orienta√ß√£o a Objetos e Design Patterns**

- Princ√≠pios SOLID aplicados ao Ruby
- Design Patterns (Factory, Singleton, Observer, Decorator, Strategy)
- Active Record Pattern e Data Mapper Pattern
- Composi√ß√£o vs Heran√ßa no Ruby
- Service Objects e Query Objects

### **3. Performance e Otimiza√ß√£o**

- Profiling de C√≥digo (Benchmark, `stackprof`, `ruby-prof`)
- Garbage Collection (GC tuning, generational GC)
- Otimiza√ß√£o de Queries com ActiveRecord
- T√©cnicas de caching (memcached, redis)

### **4. Metaprograma√ß√£o e Reflex√£o**

- `define_method`, `method_missing` e `respond_to?`
- `send` e `public_send`
- `class_eval` e `instance_eval`
- `method_added`, `included`, `extended` hooks
- DSLs internas e macros

### **5. Concorr√™ncia e Paralelismo**

- Threads (`Thread.new`, Mutex, ConditionVariable)
- Fibers e Enumerators
- Processos (`fork`, `Process.spawn`)
- Parallelism (`concurrent-ruby`, Celluloid, Sidekiq)

### **6. Testes e Qualidade de C√≥digo**

- RSpec, MiniTest, Capybara
- TDD/BDD
- Mocking e Stubbing (`double`, `allow`, `expect`)
- Cobertura de c√≥digo com SimpleCov
- Linters e ferramentas de qualidade (RuboCop, Reek, Flay, Brakeman)

### **7. Gems e Ecossistema**

- Criar e publicar gems (`gemspec`, `bundler`, `rake release`)
- Gems essenciais: Pry, Sidekiq, Faraday, Dry-rb, Sorbet, FactoryBot, Devise
- Gerenciamento de Depend√™ncias (Bundler, Gemfile.lock)

### **8. Ferramentas e Boas Pr√°ticas**

- Code Style Guide do Ruby e Rails
- Estruturas de Logs (`Logger`, `Lograge`, `Structured Logging`)
- Monitoramento e debugging (`byebug`, `pry`, `rack-mini-profiler`)
- Ruby Versions e Gerenciadores (`rbenv`, `rvm`)

---

1.

### **üìå Estruturas de Dados no Ruby**

### **Arrays**

- Criando Arrays:
    
    ```ruby
    ruby
    CopiarEditar
    arr = [1, 2, 3]
    arr = Array.new(3, "ruby") # ["ruby", "ruby", "ruby"]
    
    ```
    
- M√©todos √∫teis:
    
    ```ruby
    ruby
    CopiarEditar
    arr << 4  # Adiciona um elemento ao final
    arr.push(5) # Adiciona ao final
    arr.unshift(0) # Adiciona ao in√≠cio
    arr.pop  # Remove o √∫ltimo elemento
    arr.shift # Remove o primeiro elemento
    arr.sample # Retorna um elemento aleat√≥rio
    arr.map { |n| n * 2 } # Retorna um novo array com os valores multiplicados
    arr.select(&:even?) # Filtra elementos pares
    
    ```
    
- Diferen√ßa entre `map` e `each`:
    
    ```ruby
    ruby
    CopiarEditar
    arr.each { |n| n * 2 } # N√£o altera o array original
    arr.map { |n| n * 2 } # Retorna um novo array com os valores alterados
    
    ```
    

### **Hashes**

- Criando Hashes:
    
    ```ruby
    ruby
    CopiarEditar
    h = { nome: "Alice", idade: 25 }
    h = Hash.new(0) # Valor padr√£o
    
    ```
    
- M√©todos √∫teis:
    
    ```ruby
    ruby
    CopiarEditar
    h[:cidade] = "S√£o Paulo" # Adiciona chave/valor
    h.delete(:idade) # Remove uma chave
    h.keys # Retorna todas as chaves
    h.values # Retorna todos os valores
    h.each { |chave, valor| puts "#{chave}: #{valor}" } # Itera√ß√£o
    h.transform_keys(&:to_s) # Transforma todas as chaves em strings
    
    ```
    

### **Sets**

- √ötil para armazenar valores √∫nicos (mais eficiente que Arrays para essa finalidade).
    
    ```ruby
    ruby
    CopiarEditar
    require 'set'
    s = Set.new([1, 2, 3, 3])
    s.add(4)
    s.include?(2) # true
    s.delete(3)
    
    ```
    

### **Structs**

- Criar objetos simples sem precisar definir classes.
    
    ```ruby
    ruby
    CopiarEditar
    Pessoa = Struct.new(:nome, :idade)
    p = Pessoa.new("Jo√£o", 30)
    puts p.nome # Jo√£o
    
    ```
    

---

### **üìå Controle de Fluxo Avan√ßado**

### **Loops e Iterators**

- `loop do`: Loop infinito
    
    ```ruby
    ruby
    CopiarEditar
    loop do
      puts "Executando..."
      break if rand(10) > 8
    end
    
    ```
    
- `while` e `until`:
    
    ```ruby
    ruby
    CopiarEditar
    i = 0
    while i < 5
      puts i
      i += 1
    end
    
    i = 10
    until i < 5
      puts i
      i -= 1
    end
    
    ```
    
- `for` vs `each`:
    
    ```ruby
    ruby
    CopiarEditar
    for i in 1..5
      puts i
    end
    
    (1..5).each { |i| puts i }
    
    ```
    
- `times`, `upto`, `downto`:
    
    ```ruby
    ruby
    CopiarEditar
    3.times { puts "Ol√°" }
    1.upto(5) { |n| puts n }
    5.downto(1) { |n| puts n }
    
    ```
    

---

### **üìå Blocks, Procs e Lambdas**

### **Blocks**

- C√≥digo passado como argumento de um m√©todo:
    
    ```ruby
    ruby
    CopiarEditar
    def executar
      yield if block_given?
    end
    
    executar { puts "Executando um bloco!" }
    
    ```
    
- Passando blocos expl√≠citos (`&block`):
    
    ```ruby
    ruby
    CopiarEditar
    def executar(&bloco)
      bloco.call
    end
    
    executar { puts "Chamando um bloco explicitamente!" }
    
    ```
    

### **Procs**

- S√£o objetos e podem ser armazenados em vari√°veis:
    
    ```ruby
    ruby
    CopiarEditar
    meu_proc = Proc.new { puts "Sou um Proc!" }
    meu_proc.call
    
    ```
    

### **Lambdas**

- Funcionam como Procs, mas verificam n√∫mero correto de argumentos:
    
    ```ruby
    ruby
    CopiarEditar
    meu_lambda = ->(nome) { puts "Ol√°, #{nome}" }
    meu_lambda.call("Alice")
    
    ```
    

---

### **üìå M√©todos e Escopo**

### **Escopo de Vari√°veis**

- `local`: Dentro de m√©todos e blocos (`nome`)
- `instance`: Usada dentro de objetos (`@nome`)
- `class`: Compartilhada entre inst√¢ncias (`@@contagem`)
- `global`: Acess√≠vel de qualquer lugar (`$nome` - ‚ö†Ô∏è Evitar uso!)

### **M√©todos Private, Protected e Public**

- `public`: Padr√£o, acess√≠vel de qualquer lugar
- `private`: S√≥ pode ser chamado dentro da classe
- `protected`: Pode ser chamado dentro da classe e subclasses

```ruby
class Pessoa
  def initialize(nome)
    @nome = nome
  end

  def falar
    dizer_algo # M√©todo privado chamado internamente
  end

  private

  def dizer_algo
    puts "Ol√°, meu nome √© #{@nome}"
  end
end

p = Pessoa.new("Carlos")
p.falar # OK
p.dizer_algo # ERRO: m√©todo privado
```

---

### **üìå M√©todos Singleton e Metaprograma√ß√£o**

- Criando m√©todos de inst√¢ncia dinamicamente:
    
    ```ruby
    obj = Object.new
    def obj.meu_metodo
      "M√©todo Singleton"
    end
    puts obj.meu_metodo # OK
    ```
    
- `method_missing`: Interceptando chamadas de m√©todos inexistentes
    
    ```ruby
    class Dynamic
      def method_missing(nome, *args)
        puts "Voc√™ chamou #{nome} com #{args}"
      end
    end
    
    d = Dynamic.new
    d.algum_metodo("teste") # "Voc√™ chamou algum_metodo com ["teste"]"
    ```
    

---

### **üìå Manipula√ß√£o de Strings e Express√µes Regulares**

- Interpola√ß√£o e manipula√ß√£o
    
    ```ruby
    ruby
    CopiarEditar
    nome = "Ruby"
    puts "Ol√°, #{nome}" # Interpola√ß√£o
    puts nome.upcase # "RUBY"
    puts nome.downcase # "ruby"
    puts nome.gsub("u", "o") # "Roby"
    
    ```
    
- Express√µes Regulares
    
    ```ruby
    ruby
    CopiarEditar
    texto = "O email √© contato@email.com"
    regex = /[\w.]+@[\w.]+/
    puts texto.match(regex) # "contato@email.com"
    
    ```
    

---

### **üìå Gest√£o de Exce√ß√µes e Resili√™ncia**

- `begin-rescue`
    
    ```ruby
    ruby
    CopiarEditar
    begin
      1 / 0
    rescue ZeroDivisionError => e
      puts "Erro: #{e.message}"
    ensure
      puts "Sempre executa!"
    end
    
    ```
    
- `retry` e `raise`
    
    ```ruby
    ruby
    CopiarEditar
    tentativa = 0
    begin
      tentativa += 1
      raise "Erro!" if tentativa < 3
      puts "Sucesso na tentativa #{tentativa}"
    rescue
      retry if tentativa < 3
    end
    
    ```
    

---

---

## **üìå Duck Typing no Ruby** ü¶Ü

O conceito de **Duck Typing** vem da frase:

*"Se anda como um pato e faz 'quack' como um pato, ent√£o deve ser um pato."*

Ou seja, no Ruby, o tipo de um objeto **n√£o importa tanto quanto seu comportamento**. Em vez de verificar explicitamente o tipo de um objeto, verificamos se ele responde aos m√©todos esperados.

### **Exemplo Cl√°ssico: Sem Duck Typing (Ruim)**

```ruby
ruby
CopiarEditar
def fazer_quack(pato)
  if pato.is_a?(Pato)
    pato.quack
  else
    raise "Isso n√£o √© um pato!"
  end
end

```

Acima, estamos amarrando nosso c√≥digo a uma classe espec√≠fica (`Pato`), o que reduz flexibilidade.

### **Com Duck Typing (Melhor)**

```ruby
ruby
CopiarEditar
def fazer_quack(animal)
  animal.quack
end

class Pato
  def quack
    puts "Quack! ü¶Ü"
  end
end

class Pessoa
  def quack
    puts "Estou imitando um pato! üó£Ô∏è"
  end
end

pato = Pato.new
humano = Pessoa.new

fazer_quack(pato)  # Quack! ü¶Ü
fazer_quack(humano) # Estou imitando um pato! üó£Ô∏è

```

‚úÖ **Vantagem**: O m√©todo `fazer_quack` funciona com qualquer objeto que tenha o m√©todo `quack`, sem se preocupar com o tipo.

### **Verificando se um objeto responde a um m√©todo**

Se quisermos ser mais seguros, podemos usar `respond_to?`:

```ruby
ruby
CopiarEditar
def fazer_quack(animal)
  if animal.respond_to?(:quack)
    animal.quack
  else
    puts "Isso n√£o sabe fazer quack!"
  end
end

```

Agora, s√≥ chamamos `quack` se o objeto realmente tiver esse m√©todo.

---

## **üìå Polimorfismo no Ruby** üèõÔ∏è

**Polimorfismo** significa "muitas formas" e permite que diferentes classes compartilhem **a mesma interface** (ou conjunto de m√©todos) sem necessidade de heran√ßa.

### **1Ô∏è‚É£ Polimorfismo via Heran√ßa**

Aqui, classes diferentes herdam de uma classe base e sobrescrevem m√©todos.

```ruby
ruby
CopiarEditar
class Animal
  def falar
    "Som gen√©rico"
  end
end

class Cachorro < Animal
  def falar
    "Au au! üê∂"
  end
end

class Gato < Animal
  def falar
    "Miau! üê±"
  end
end

animais = [Cachorro.new, Gato.new]

animais.each { |animal| puts animal.falar }
# Sa√≠da:
# "Au au! üê∂"
# "Miau! üê±"

```

‚úÖ **Vantagem**: Podemos tratar `Cachorro` e `Gato` como `Animal` sem se preocupar com suas classes espec√≠ficas.

---

### **2Ô∏è‚É£ Polimorfismo via Duck Typing (Sem Heran√ßa)**

O Ruby permite polimorfismo sem heran√ßa, apenas exigindo que os objetos implementem um mesmo m√©todo.

```ruby
ruby
CopiarEditar
class Email
  def enviar
    puts "Enviando email... üìß"
  end
end

class SMS
  def enviar
    puts "Enviando SMS... üì≤"
  end
end

class NotificacaoPush
  def enviar
    puts "Enviando Push Notification... üîî"
  end
end

# M√©todo gen√©rico que aceita qualquer objeto que tenha 'enviar'
def notificar(metodo)
  metodo.enviar
end

notificar(Email.new)  # Enviando email...
notificar(SMS.new)    # Enviando SMS...
notificar(NotificacaoPush.new) # Enviando Push Notification...

```

‚úÖ **Vantagem**: Qualquer classe que tenha `enviar` pode ser usada sem precisar de uma hierarquia de heran√ßa.

---

### **Conclus√£o**

1. **Duck Typing** permite criar c√≥digo mais flex√≠vel ao focar no comportamento dos objetos, n√£o em sua classe.
2. **Polimorfismo** ajuda a criar c√≥digo reutiliz√°vel e extens√≠vel, seja via heran√ßa ou via Duck Typing.

---

# **üìå 2. Orienta√ß√£o a Objetos e Design Patterns**

## **1Ô∏è‚É£ Princ√≠pios SOLID no Ruby**

Os princ√≠pios SOLID ajudam a escrever c√≥digo limpo, modular e extens√≠vel.

### **‚úÖ S ‚Äî Single Responsibility Principle (SRP)**

*"Uma classe deve ter apenas uma √∫nica raz√£o para mudar."*

**‚ùå Exemplo ruim (m√∫ltiplas responsabilidades):**

```ruby
ruby
CopiarEditar
class Relatorio
  def gerar
    puts "Gerando relat√≥rio..."
  end

  def salvar_no_banco
    puts "Salvando no banco de dados..."
  end
end

```

Essa classe faz **duas coisas**: gera e salva um relat√≥rio.

**‚úÖ Exemplo bom (separando responsabilidades):**

```ruby
ruby
CopiarEditar
class GeradorDeRelatorio
  def gerar
    puts "Gerando relat√≥rio..."
  end
end

class SalvarRelatorio
  def salvar
    puts "Salvando no banco de dados..."
  end
end

```

Agora cada classe tem **apenas uma responsabilidade**.

---

### **‚úÖ O ‚Äî Open/Closed Principle (OCP)**

*"Uma classe deve estar aberta para extens√£o, mas fechada para modifica√ß√£o."*

**‚ùå Exemplo ruim (modificando a classe sempre que um novo tipo de relat√≥rio aparece):**

```ruby
ruby
CopiarEditar
class Relatorio
  def gerar(tipo)
    if tipo == :pdf
      puts "Gerando PDF..."
    elsif tipo == :csv
      puts "Gerando CSV..."
    end
  end
end

```

A cada novo formato, precisamos modificar a classe.

**‚úÖ Exemplo bom (uso de heran√ßa para extens√£o):**

```ruby
ruby
CopiarEditar
class Relatorio
  def gerar
    raise "Deve ser implementado pela subclasse"
  end
end

class RelatorioPDF < Relatorio
  def gerar
    puts "Gerando PDF..."
  end
end

class RelatorioCSV < Relatorio
  def gerar
    puts "Gerando CSV..."
  end
end

```

Agora podemos adicionar novos tipos de relat√≥rios **sem modificar** a classe original.

---

### **‚úÖ L ‚Äî Liskov Substitution Principle (LSP)**

*"Se uma classe filha substitui a classe pai, ela deve manter o comportamento esperado."*

**‚ùå Exemplo ruim (classe filha alterando o comportamento da classe pai):**

```ruby
ruby
CopiarEditar
class Ave
  def voar
    puts "Voando..."
  end
end

class Pinguim < Ave
end

pinguim = Pinguim.new
pinguim.voar  # ‚ùå ERRO! Pinguins n√£o voam

```

A classe `Pinguim` **n√£o deveria herdar** de `Ave` se n√£o consegue voar.

**‚úÖ Exemplo bom (corrigindo com composi√ß√£o):**

```ruby
ruby
CopiarEditar
class Ave
end

class Voador
  def voar
    puts "Voando..."
  end
end

class Pinguim < Ave
end

class Andorinha < Ave
  include Voador
end

Andorinha.new.voar # "Voando..."

```

Agora, s√≥ **aves que voam** t√™m o comportamento de voo.

---

### **‚úÖ I ‚Äî Interface Segregation Principle (ISP)**

*"Uma classe n√£o deve ser for√ßada a implementar m√©todos que n√£o usa."*

**‚ùå Exemplo ruim (classe for√ßada a implementar m√©todos irrelevantes):**

```ruby
ruby
CopiarEditar
class Trabalhador
  def programar
    raise "Deve ser implementado"
  end

  def atender_clientes
    raise "Deve ser implementado"
  end
end

class Desenvolvedor < Trabalhador
  def programar
    puts "Codando..."
  end

  def atender_clientes
    puts "Fazendo atendimento t√©cnico..." # üò¨ Ruim!
  end
end

```

A classe `Desenvolvedor` **n√£o deveria ter que implementar** `atender_clientes`.

**‚úÖ Exemplo bom (criando interfaces separadas):**

```ruby
ruby
CopiarEditar
module Programador
  def programar
    puts "Codando..."
  end
end

module Atendimento
  def atender_clientes
    puts "Falando com clientes..."
  end
end

class Desenvolvedor
  include Programador
end

class Suporte
  include Atendimento
end

```

Agora cada classe implementa **apenas o que precisa**.

---

### **‚úÖ D ‚Äî Dependency Inversion Principle (DIP)**

*"M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel diretamente."*

**‚ùå Exemplo ruim (depend√™ncia direta em uma classe espec√≠fica):**

```ruby
ruby
CopiarEditar
class MySQLDatabase
  def salvar
    puts "Salvando no MySQL..."
  end
end

class Servico
  def initialize
    @banco = MySQLDatabase.new
  end

  def salvar_dados
    @banco.salvar
  end
end

```

O `Servico` depende diretamente do `MySQLDatabase`, dificultando a troca para outro banco.

**‚úÖ Exemplo bom (uso de abstra√ß√£o para independ√™ncia):**

```ruby
ruby
CopiarEditar
class Database
  def salvar
    raise "Deve ser implementado"
  end
end

class MySQLDatabase < Database
  def salvar
    puts "Salvando no MySQL..."
  end
end

class Servico
  def initialize(banco)
    @banco = banco
  end

  def salvar_dados
    @banco.salvar
  end
end

banco = MySQLDatabase.new
Servico.new(banco).salvar_dados # "Salvando no MySQL..."

```

Agora podemos trocar `MySQLDatabase` por qualquer outro banco **sem modificar o c√≥digo da `Servico`**.

---

## **2Ô∏è‚É£ Design Patterns no Ruby**

### **‚úÖ Factory Pattern**

Facilita a cria√ß√£o de objetos sem expor a l√≥gica de inst√¢ncia.

```ruby
ruby
CopiarEditar
class Animal
  def falar
    raise "Deve ser implementado"
  end
end

class Cachorro < Animal
  def falar
    "Au au!"
  end
end

class Gato < Animal
  def falar
    "Miau!"
  end
end

class AnimalFactory
  def self.criar(tipo)
    case tipo
    when :cachorro then Cachorro.new
    when :gato then Gato.new
    else raise "Tipo desconhecido"
    end
  end
end

animal = AnimalFactory.criar(:cachorro)
puts animal.falar # "Au au!"

```

---

### **‚úÖ Singleton Pattern**

Garante que apenas **uma inst√¢ncia** da classe seja criada.

```ruby
ruby
CopiarEditar
require 'singleton'

class Configuracao
  include Singleton

  attr_accessor :tema

  def initialize
    @tema = "Escuro"
  end
end

config1 = Configuracao.instance
config2 = Configuracao.instance

puts config1.object_id == config2.object_id # true (mesmo objeto)

```

---

### **‚úÖ Observer Pattern**

Permite que m√∫ltiplos objetos sejam notificados quando algo acontece.

```ruby
ruby
CopiarEditar
class Publicador
  attr_reader :observadores

  def initialize
    @observadores = []
  end

  def adicionar_observador(observador)
    @observadores << observador
  end

  def notificar
    @observadores.each(&:atualizar)
  end
end

class Assinante
  def atualizar
    puts "Recebi uma atualiza√ß√£o!"
  end
end

noticia = Publicador.new
joao = Assinante.new

noticia.adicionar_observador(joao)
noticia.notificar # "Recebi uma atualiza√ß√£o!"

```

---

# **üìå 3. Performance e Otimiza√ß√£o** üöÄ

A otimiza√ß√£o de performance no Ruby envolve **profiling de c√≥digo, garbage collection tuning, otimiza√ß√£o de queries e t√©cnicas de caching**. Vamos explorar cada um desses t√≥picos em detalhes.

---

## **1Ô∏è‚É£ Profiling de C√≥digo (Benchmark, stackprof, ruby-prof)**

O primeiro passo para otimizar o c√≥digo √© **descobrir onde est√£o os gargalos**. Para isso, usamos ferramentas de **profiling** que analisam tempo de execu√ß√£o e consumo de CPU/mem√≥ria.

### **‚úÖ Benchmark (Medi√ß√£o Simples de Tempo)**

O m√≥dulo `Benchmark` √© √∫til para medir o tempo de execu√ß√£o de um bloco de c√≥digo.

```ruby
ruby
CopiarEditar
require 'benchmark'

tempo = Benchmark.measure do
  100_000.times { "Ruby".reverse }
end

puts tempo.real  # Tempo total em segundos

```

‚úÖ **Quando usar?**

- Comparar m√©todos diferentes e escolher o mais r√°pido.
- Medir tempo total de execu√ß√£o de partes espec√≠ficas do c√≥digo.

---

### **‚úÖ stackprof (Profiling de CPU e Mem√≥ria)**

O **stackprof** √© √∫til para detectar onde o c√≥digo est√° gastando mais tempo.

**Instala√ß√£o:**

```
gem install stackprof

```

**Uso:**

```ruby
ruby
CopiarEditar
require 'stackprof'

StackProf.run(mode: :cpu, out: 'stackprof.dump') do
  1_000_000.times { "Ruby".reverse }
end

```

Depois, analisamos o relat√≥rio gerado:

```
stackprof stackprof.dump --text

```

‚úÖ **Quando usar?**

- Identificar quais m√©todos est√£o consumindo mais CPU.
- Encontrar gargalos espec√≠ficos dentro do c√≥digo.

---

### **‚úÖ ruby-prof (Profiling Detalhado)**

O `ruby-prof` fornece um relat√≥rio detalhado de tempo de CPU, chamadas de m√©todo e uso de mem√≥ria.

**Instala√ß√£o:**

```
gem install ruby-prof

```

**Uso:**

```ruby
ruby
CopiarEditar
require 'ruby-prof'

RubyProf.start
100_000.times { "Ruby".reverse }
result = RubyProf.stop

# Exibir o relat√≥rio no terminal
RubyProf::FlatPrinter.new(result).print(STDOUT)

```

‚úÖ **Quando usar?**

- Precisa de um perfil detalhado de execu√ß√£o.
- Descobrir quais m√©todos est√£o gastando mais tempo.

---

## **2Ô∏è‚É£ Garbage Collection (GC tuning, generational GC)**

O **Garbage Collector (GC)** do Ruby remove objetos n√£o utilizados para liberar mem√≥ria. Por√©m, rod√°-lo muitas vezes pode prejudicar a performance.

### **‚úÖ Como funciona o GC no Ruby?**

- Ruby usa um **GC generacional**:
    - **Objetos jovens** s√£o coletados rapidamente.
    - **Objetos antigos** s√£o verificados com menos frequ√™ncia.
- O GC roda automaticamente, mas pode ser ajustado.

### **‚úÖ Otimizando o GC**

Podemos ajustar as vari√°veis de ambiente para melhorar a performance.

```
export RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR=2

```

Isso faz com que o GC colete objetos antigos **com menos frequ√™ncia**, reduzindo pausas na execu√ß√£o.

Tamb√©m podemos **for√ßar a execu√ß√£o do GC manualmente** (com cuidado!):

```ruby
ruby
CopiarEditar
GC.start

```

‚úÖ **Quando otimizar o GC?**

- Aplica√ß√µes com **muita aloca√ß√£o e libera√ß√£o de objetos**.
- Reduzir pausas do GC em **aplica√ß√µes de tempo real**.

---

## **3Ô∏è‚É£ Otimiza√ß√£o de Queries com ActiveRecord**

O ActiveRecord do Rails pode gerar queries ineficientes se n√£o for bem utilizado.

### **‚úÖ Evitar N+1 Queries**

**Problema:**

```ruby
ruby
CopiarEditar
Post.all.each do |post|
  puts post.comments.count
end

```

Isso gera **uma query para buscar os posts + uma query para cada post** (N+1 queries).

**Solu√ß√£o:**

```ruby
ruby
CopiarEditar
Post.includes(:comments).each do |post|
  puts post.comments.count
end

```

Agora, o ActiveRecord faz **apenas duas queries**:

- Uma para buscar os posts.
- Outra para buscar os coment√°rios de todos os posts.

---

### **‚úÖ Usar `select` para evitar carga excessiva**

Se n√£o precisarmos de todos os campos de uma tabela, podemos otimizar a query:

```ruby
ruby
CopiarEditar
User.select(:id, :name).where(active: true)

```

Isso evita carregar colunas desnecess√°rias.

---

### **‚úÖ √çndices no Banco de Dados**

Adicionar √≠ndices melhora a performance das buscas.

```ruby
ruby
CopiarEditar
class AddIndexToUsers < ActiveRecord::Migration[6.0]
  def change
    add_index :users, :email, unique: true
  end
end

```

‚úÖ **Quando otimizar queries?**

- Se notar **queries lentas no banco**.
- Se o **N+1 Query Problem** estiver impactando a aplica√ß√£o.
- Se tabelas grandes estiverem **sem √≠ndices**.

---

## **4Ô∏è‚É£ T√©cnicas de Caching (memcached, redis)**

Caching reduz o tempo de resposta armazenando dados frequentemente acessados.

### **‚úÖ Fragment Caching (Rails)**

Podemos armazenar partes de views no cache para melhorar performance.

```
erb
CopiarEditar
<% cache @article do %>
  <h1><%= @article.title %></h1>
  <p><%= @article.body %></p>
<% end %>

```

Isso evita processar a mesma view toda vez.

---

### **‚úÖ Memcached**

**Instala√ß√£o:**

```
brew install memcached
gem install dalli

```

**Configura√ß√£o no Rails (`config/environments/production.rb`)**:

```ruby
ruby
CopiarEditar
config.cache_store = :mem_cache_store, "localhost"

```

**Uso no c√≥digo:**

```ruby
ruby
CopiarEditar
Rails.cache.write("chave", "valor", expires_in: 5.minutes)
Rails.cache.read("chave")

```

‚úÖ **Quando usar?**

- Melhorar tempo de resposta de aplica√ß√µes Rails.
- Evitar processamento repetitivo de dados frequentemente usados.

---

### **‚úÖ Redis (Caching e Background Jobs)**

**Instala√ß√£o:**

```
brew install redis
gem install redis

```

**Configura√ß√£o no Rails (`config/environments/production.rb`)**:

```ruby
ruby
CopiarEditar
config.cache_store = :redis_cache_store, { url: "redis://localhost:6379/0" }

```

**Uso no c√≥digo:**

```ruby
ruby
CopiarEditar
Rails.cache.write("user_1", { nome: "Jo√£o" }, expires_in: 10.minutes)
Rails.cache.read("user_1")

```

‚úÖ **Quando usar?**

- Cache de alta performance para dados din√¢micos.
- Background jobs no Sidekiq (que usa Redis).

---

## **üìå Conclus√£o**

1. **Profiling de C√≥digo**
    - `Benchmark` para medi√ß√µes simples.
    - `stackprof` para profiling de CPU/mem√≥ria.
    - `ruby-prof` para an√°lise detalhada de performance.
2. **Garbage Collection (GC tuning)**
    - Ruby usa GC generacional.
    - Ajustes no GC podem reduzir pausas e melhorar performance.
3. **Otimiza√ß√£o de Queries no ActiveRecord**
    - **Evitar N+1 queries** com `includes`.
    - **Usar `select`** para carregar menos dados.
    - **Criar √≠ndices no banco** para buscas r√°pidas.
4. **Caching (memcached, Redis)**
    - **Fragment Caching** no Rails.
    - **Memcached** para armazenar dados frequentemente acessados.
    - **Redis** para cache r√°pido e background jobs.

---

# **üìå 4. Metaprograma√ß√£o e Reflex√£o** üöÄ

Metaprograma√ß√£o no Ruby permite **modificar classes e m√©todos em tempo de execu√ß√£o**, criar **DSLs (Domain-Specific Languages)** e at√© definir c√≥digo dinamicamente.

---

## **1Ô∏è‚É£ `define_method`, `method_missing` e `respond_to?`**

### **‚úÖ `define_method` (Criando M√©todos Dinamicamente)**

Usamos `define_method` para **criar m√©todos em tempo de execu√ß√£o** dentro de uma classe.

```ruby
ruby
CopiarEditar
class Pessoa
  [:nome, :idade, :cidade].each do |atributo|
    define_method(atributo) do
      instance_variable_get("@#{atributo}")
    end

    define_method("#{atributo}=") do |valor|
      instance_variable_set("@#{atributo}", valor)
    end
  end
end

p = Pessoa.new
p.nome = "Jo√£o"
p.idade = 30

puts p.nome  # "Jo√£o"
puts p.idade # 30

```

‚úÖ **Quando usar?**

- Criar m√©todos dinamicamente para reduzir repeti√ß√£o.
- Implementar **APIs din√¢micas**.

---

### **‚úÖ `method_missing` (Interceptando Chamadas de M√©todo Inexistentes)**

Chamado quando um m√©todo **n√£o existe**.

```ruby
ruby
CopiarEditar
class Config
  def method_missing(nome, *args)
    if nome.to_s.start_with?("get_")
      chave = nome.to_s.split("_", 2).last
      puts "Buscando configura√ß√£o: #{chave}"
    else
      super
    end
  end
end

config = Config.new
config.get_database # "Buscando configura√ß√£o: database"
config.get_api_key  # "Buscando configura√ß√£o: api_key"

```

**‚ö†Ô∏è Cuidado!**

- Pode dificultar debugging.
- Sempre chame `super` para m√©todos que n√£o deseja interceptar.

---

### **‚úÖ `respond_to?` (Verificando Se um M√©todo Existe)**

Usado para evitar erros ao chamar m√©todos desconhecidos.

```ruby
ruby
CopiarEditar
class Exemplo
  def teste
    "ok"
  end
end

e = Exemplo.new
puts e.respond_to?(:teste)        # true
puts e.respond_to?(:nao_existe)   # false

```

‚úÖ **Quando usar?**

- Evitar chamadas a `method_missing` em m√©todos inv√°lidos.
- Melhor compatibilidade com bibliotecas externas.

---

## **2Ô∏è‚É£ `send` e `public_send`**

### **‚úÖ `send` (Chamando M√©todos de Forma Din√¢mica)**

Podemos chamar m√©todos mesmo sem conhec√™-los antecipadamente.

```ruby
ruby
CopiarEditar
class Pessoa
  def saudacao
    "Ol√°!"
  end
end

pessoa = Pessoa.new
puts pessoa.send(:saudacao) # "Ol√°!"

```

**‚ö†Ô∏è `send` ignora visibilidade!**

```ruby
ruby
CopiarEditar
class Exemplo
  private
  def segredo
    "N√£o deveria ser acess√≠vel!"
  end
end

e = Exemplo.new
puts e.send(:segredo) # "N√£o deveria ser acess√≠vel!"

```

### **‚úÖ `public_send` (Respeita a Visibilidade do M√©todo)**

Para **evitar chamar m√©todos privados**, use `public_send`.

```ruby
ruby
CopiarEditar
puts e.public_send(:segredo) # Erro: m√©todo privado

```

‚úÖ **Quando usar?**

- `send`: Quando precisa acessar m√©todos privados (com cautela).
- `public_send`: Quando s√≥ precisa de m√©todos p√∫blicos.

---

## **3Ô∏è‚É£ `class_eval` e `instance_eval`**

### **‚úÖ `class_eval` (Modificando Classes em Tempo de Execu√ß√£o)**

Permite adicionar m√©todos ou modificar classes **de fora dela**.

```ruby
ruby
CopiarEditar
class Pessoa; end

Pessoa.class_eval do
  def falar
    "Oi!"
  end
end

puts Pessoa.new.falar # "Oi!"

```

‚úÖ **Quando usar?**

- Adicionar m√©todos a uma classe dinamicamente.

---

### **‚úÖ `instance_eval` (Modificando Apenas uma Inst√¢ncia)**

Altera **apenas um objeto espec√≠fico**.

```ruby
ruby
CopiarEditar
p = Pessoa.new

p.instance_eval do
  def segredo
    "Segredo s√≥ para esta inst√¢ncia!"
  end
end

puts p.segredo # "Segredo s√≥ para esta inst√¢ncia!"

```

‚úÖ **Quando usar?**

- Modificar **apenas uma inst√¢ncia**, sem impactar toda a classe.

---

## **4Ô∏è‚É£ `method_added`, `included`, `extended` Hooks**

### **‚úÖ `method_added` (Intercepta a Defini√ß√£o de M√©todos)**

Executa c√≥digo sempre que um novo m√©todo for definido.

```ruby
ruby
CopiarEditar
class Teste
  def self.method_added(nome)
    puts "M√©todo #{nome} foi adicionado!"
  end

  def ola
    puts "Oi!"
  end
end

# "M√©todo ola foi adicionado!"

```

‚úÖ **Quando usar?**

- Logar cria√ß√£o de m√©todos.
- Aplicar restri√ß√µes em tempo de execu√ß√£o.

---

### **‚úÖ `included` e `extended` (Executando C√≥digo ao Incluir um M√≥dulo)**

**`included`** ‚Üí Chamado quando um m√≥dulo √© **inclu√≠do** em uma classe.

**`extended`** ‚Üí Chamado quando um m√≥dulo √© **extendido** por uma classe.

```ruby
ruby
CopiarEditar
module MeuModulo
  def self.included(base)
    puts "#{base} incluiu #{self}"
  end

  def self.extended(base)
    puts "#{base} estendeu #{self}"
  end
end

class MinhaClasse
  include MeuModulo
end
# "MinhaClasse incluiu MeuModulo"

obj = Object.new
obj.extend(MeuModulo)
# "#<Object:0x00007ff> estendeu MeuModulo"

```

‚úÖ **Quando usar?**

- **Executar l√≥gica** quando um m√≥dulo for inclu√≠do/extendido.
- Criar **DSLs que configuram classes dinamicamente**.

---

## **5Ô∏è‚É£ DSLs Internas e Macros**

DSLs (Domain-Specific Languages) permitem criar APIs elegantes no Ruby.

### **‚úÖ Exemplo de DSL (Simula√ß√£o de Configura√ß√£o)**

```ruby
ruby
CopiarEditar
class Config
  def self.definir(nome, valor)
    define_method(nome) { valor }
  end
end

class AppConfig < Config
  definir :app_name, "MeuApp"
  definir :versao, "1.0.0"
end

config = AppConfig.new
puts config.app_name # "MeuApp"
puts config.versao   # "1.0.0"

```

‚úÖ **Quando usar?**

- Criar APIs elegantes, como o `ActiveRecord`.

---

### **‚úÖ Macros (Defini√ß√£o de M√©todos de Forma Elegante)**

```ruby
ruby
CopiarEditar
class MeuModelo
  def self.campo(nome)
    define_method(nome) do
      instance_variable_get("@#{nome}")
    end

    define_method("#{nome}=") do |valor|
      instance_variable_set("@#{nome}", valor)
    end
  end
end

class Usuario < MeuModelo
  campo :nome
  campo :email
end

u = Usuario.new
u.nome = "Jo√£o"
puts u.nome # "Jo√£o"

```

‚úÖ **Quando usar?**

- Criar DSLs elegantes no estilo Rails.

---

# **üìå Conclus√£o**

1. **M√©todos Din√¢micos**
    - `define_method`: Cria m√©todos dinamicamente.
    - `method_missing`: Intercepta chamadas de m√©todos inexistentes.
    - `respond_to?`: Verifica se um m√©todo existe.
2. **Execu√ß√£o Din√¢mica**
    - `send`: Chama m√©todos dinamicamente (inclui privados).
    - `public_send`: Chama m√©todos p√∫blicos dinamicamente.
3. **Avalia√ß√£o de C√≥digo**
    - `class_eval`: Modifica classes.
    - `instance_eval`: Modifica uma √∫nica inst√¢ncia.
4. **Hooks e Callbacks**
    - `method_added`: Executa c√≥digo ao definir um m√©todo.
    - `included` e `extended`: Executam c√≥digo ao incluir m√≥dulos.
5. **DSLs e Macros**
    - Criam APIs elegantes e flex√≠veis.

---

# **üìå 5. Concorr√™ncia e Paralelismo** üöÄ

Concorr√™ncia permite que m√∫ltiplas tarefas rodem simultaneamente, enquanto paralelismo permite que rodem **ao mesmo tempo em m√∫ltiplos n√∫cleos de CPU**.

---

## **1Ô∏è‚É£ Threads (`Thread.new`, `Mutex`, `ConditionVariable`)**

Threads permitem **executar tarefas concorrentes** dentro do mesmo processo.

### **‚úÖ Criando Threads Simples (`Thread.new`)**

```ruby
ruby
CopiarEditar
threads = []

5.times do |i|
  threads << Thread.new do
    sleep(rand(1..3))
    puts "Thread #{i} terminou!"
  end
end

threads.each(&:join)

```

**‚ö†Ô∏è Problema:** Sem controle, m√∫ltiplas threads podem acessar os mesmos dados ao mesmo tempo, causando **race conditions**.

---

### **‚úÖ `Mutex` (Evitando Condi√ß√µes de Corrida)**

O **Mutex (Mutual Exclusion)** impede que m√∫ltiplas threads acessem um recurso simultaneamente.

```ruby
ruby
CopiarEditar
mutex = Mutex.new
saldo = 100

threads = 5.times.map do
  Thread.new do
    mutex.synchronize do
      temp = saldo
      sleep(0.1)  # Simulando um atraso
      saldo = temp - 10
    end
  end
end

threads.each(&:join)
puts "Saldo final: #{saldo}"  # Saldo correto!

```

‚úÖ **Quando usar?**

- Proteger **recursos compartilhados** contra condi√ß√µes de corrida.

---

### **‚úÖ `ConditionVariable` (Controle de Sincroniza√ß√£o entre Threads)**

Usamos `ConditionVariable` para **permitir que uma thread espere um evento** antes de continuar.

```ruby
ruby
CopiarEditar
mutex = Mutex.new
cond_var = ConditionVariable.new
pronto = false

produtor = Thread.new do
  mutex.synchronize do
    sleep 2
    pronto = true
    cond_var.signal
  end
end

consumidor = Thread.new do
  mutex.synchronize do
    cond_var.wait(mutex) until pronto
    puts "Consumidor recebeu o sinal!"
  end
end

[produtor, consumidor].each(&:join)

```

‚úÖ **Quando usar?**

- Quando uma **thread depende de outra para continuar**.

---

## **2Ô∏è‚É£ Fibers e Enumerators**

**Fibers** s√£o **corrotinas leves** que oferecem mais controle que threads, permitindo **pausar e retomar manualmente a execu√ß√£o**.

### **‚úÖ Criando um Fiber**

```ruby
ruby
CopiarEditar
fiber = Fiber.new do
  puts "Iniciando Fiber"
  Fiber.yield
  puts "Continuando Fiber"
end

fiber.resume  # "Iniciando Fiber"
fiber.resume  # "Continuando Fiber"

```

**‚ö†Ô∏è Limita√ß√£o:** Diferente de threads, Fibers **n√£o s√£o concorrentes**, mas sim **cooperativos** (executam quando chamados).

---

### **‚úÖ Enumerators como Geradores (Lazy Evaluation)**

Podemos usar `Enumerator` para **processar grandes volumes de dados** sem carregar tudo na mem√≥ria.

```ruby
ruby
CopiarEditar
enumerator = Enumerator.new do |yielder|
  10.times do |i|
    sleep(1)
    yielder << i
  end
end

puts enumerator.next  # 0
puts enumerator.next  # 1

```

‚úÖ **Quando usar?**

- Para processar **streams de dados grandes sem ocupar muita mem√≥ria**.

---

## **3Ô∏è‚É£ Processos (`fork`, `Process.spawn`)**

Diferente das threads, que compartilham mem√≥ria, **processos s√£o independentes**, cada um com seu pr√≥prio espa√ßo de mem√≥ria.

### **‚úÖ `fork` (Criando um Novo Processo)**

```ruby
ruby
CopiarEditar
pid = fork do
  puts "Processo filho rodando (PID: #{Process.pid})"
  sleep 2
end

puts "Processo pai esperando filho (PID: #{pid})"
Process.wait(pid)  # Aguarda o processo filho terminar

```

‚úÖ **Quando usar?**

- Para **executar tarefas em paralelo sem problemas de compartilhamento de mem√≥ria**.

---

### **‚úÖ `Process.spawn` (Executar Comandos Externos sem Bloquear)**

Diferente de `fork`, `Process.spawn` **n√£o bloqueia a execu√ß√£o do programa principal**.

```ruby
ruby
CopiarEditar
pid = Process.spawn("sleep 5")
puts "Processo #{pid} iniciado"
Process.wait(pid)
puts "Processo #{pid} terminou"

```

‚úÖ **Quando usar?**

- Para rodar **processos externos** sem bloquear o c√≥digo Ruby.

---

## **4Ô∏è‚É£ Paralelismo (Concurrent-ruby, Celluloid, Sidekiq)**

Como Ruby tem **GIL**, precisamos de **gems externas** para rodar c√≥digo realmente em paralelo.

---

### **‚úÖ `concurrent-ruby` (Thread Pool)**

`concurrent-ruby` permite **executar tarefas em paralelo usando um pool de threads**.

**Instala√ß√£o:**

```
gem install concurrent-ruby

```

**Uso:**

```ruby
ruby
CopiarEditar
require 'concurrent'

pool = Concurrent::FixedThreadPool.new(5)

10.times do |i|
  pool.post { puts "Tarefa #{i} executada na thread #{Thread.current}" }
end

pool.shutdown
pool.wait_for_termination

```

‚úÖ **Quando usar?**

- Para **executar muitas tarefas simultaneamente sem criar milhares de threads**.

---

### **‚úÖ Sidekiq (Processamento de Background com Redis)**

Sidekiq usa **processos separados** para rodar jobs de background paralelamente.

**Instala√ß√£o:**

```
gem install sidekiq

```

**Defini√ß√£o de um job:**

```ruby
ruby
CopiarEditar
class MeuJob
  include Sidekiq::Worker

  def perform(nome)
    puts "Processando #{nome}"
  end
end

```

**Execu√ß√£o do job:**

```ruby
ruby
CopiarEditar
MeuJob.perform_async("Tarefa 1")

```

‚úÖ **Quando usar?**

- Para **tarefas ass√≠ncronas** como envio de e-mails, processamento de imagens, etc.

---

# **üìå Conclus√£o**

1. **Threads (Concorr√™ncia no Mesmo Processo)**
    - `Thread.new`: Cria threads concorrentes.
    - `Mutex`: Evita race conditions.
    - `ConditionVariable`: Coordena a execu√ß√£o entre threads.
2. **Fibers (Corrotinas Leves)**
    - Permitem **pausar e retomar** c√≥digo manualmente.
    - √öteis para **processamento ass√≠ncrono de dados**.
3. **Processos (Paralelismo Real)**
    - `fork`: Cria um processo filho.
    - `Process.spawn`: Executa comandos externos.
4. **Bibliotecas de Paralelismo**
    - `concurrent-ruby`: Pool de threads eficiente.
    - `Sidekiq`: Jobs de background com Redis.

---

# **üìå 6. Testes e Qualidade de C√≥digo** üöÄ

Ruby tem um **ecossistema forte de testes**, e escrever **c√≥digo test√°vel** √© essencial para garantir manutenibilidade e evitar bugs.

---

## **1Ô∏è‚É£ RSpec, MiniTest, Capybara**

### **‚úÖ RSpec (Framework de Testes Mais Usado)**

RSpec √© **descritivo e expressivo**, ideal para TDD e BDD.

üìå **Instala√ß√£o:**

```
gem install rspec
rspec --init

```

üìå **Testando uma Classe com RSpec:**

```ruby
ruby
CopiarEditar
# lib/calculadora.rb
class Calculadora
  def soma(a, b)
    a + b
  end
end

```

```ruby
ruby
CopiarEditar
# spec/calculadora_spec.rb
require_relative '../lib/calculadora'

RSpec.describe Calculadora do
  it "soma dois n√∫meros corretamente" do
    calc = Calculadora.new
    expect(calc.soma(2, 3)).to eq(5)
  end
end

```

üìå **Rodando os testes:**

```
rspec

```

‚úÖ **Por que usar?**

- DSL leg√≠vel.
- F√°cil integra√ß√£o com Mocking e Stubbing.

---

### **‚úÖ MiniTest (Incluso no Ruby, Alternativa ao RSpec)**

```ruby
ruby
CopiarEditar
require 'minitest/autorun'

class TestCalculadora < Minitest::Test
  def test_soma
    assert_equal 5, Calculadora.new.soma(2, 3)
  end
end

```

‚úÖ **Quando usar?**

- Quando quer **tests minimalistas e r√°pidos** sem depend√™ncias extras.

---

### **‚úÖ Capybara (Testes de Integra√ß√£o e E2E)**

Capybara √© usado para **testes de interface simulando um usu√°rio real**.

üìå **Instala√ß√£o:**

```
gem install capybara

```

üìå **Exemplo de Teste de UI:**

```ruby
ruby
CopiarEditar
require 'capybara/rspec'

Capybara.app = MeuApp

describe "P√°gina Inicial", type: :feature do
  it "exibe o t√≠tulo corretamente" do
    visit '/'
    expect(page).to have_content("Bem-vindo")
  end
end

```

‚úÖ **Quando usar?**

- Testar **fluxos de usu√°rio** no navegador.

---

## **2Ô∏è‚É£ TDD e BDD (Test-Driven Development e Behavior-Driven Development)**

### **‚úÖ TDD (Test-Driven Development)**

Fluxo de TDD:

1. **Escreva um teste que falha**.
2. **Implemente a funcionalidade m√≠nima para passar no teste**.
3. **Refatore o c√≥digo sem quebrar os testes**.

üìå **Exemplo de TDD em A√ß√£o:**

```ruby
ruby
CopiarEditar
# Escrevemos o teste primeiro
it "retorna verdadeiro se o n√∫mero √© par" do
  expect(Numero.par?(4)).to be true
end

```

```ruby
ruby
CopiarEditar
# Implementamos o c√≥digo depois
class Numero
  def self.par?(num)
    num.even?
  end
end

```

### **‚úÖ BDD (Behavior-Driven Development)**

BDD se foca no **comportamento do sistema**.

```ruby
ruby
CopiarEditar
describe "Login de Usu√°rio" do
  it "permite um usu√°rio v√°lido fazer login" do
    usuario = Usuario.new("email@example.com", "senha123")
    expect(usuario.login).to eq("Bem-vindo!")
  end
end

```

‚úÖ **Quando usar?**

- **TDD** para c√≥digo bem estruturado e f√°cil de testar.
- **BDD** para descrever comportamento esperado de forma clara.

---

## **3Ô∏è‚É£ Mocking e Stubbing (`double`, `allow`, `expect`)**

Mocking e Stubbing s√£o usados para **simular comportamentos de objetos sem precisar de implementa√ß√µes reais**.

### **‚úÖ Criando um Mock (`double`)**

```ruby
ruby
CopiarEditar
usuario = double("Usuario", nome: "Jo√£o")
puts usuario.nome  # "Jo√£o"

```

### **‚úÖ Stubbing (`allow`)**

```ruby
ruby
CopiarEditar
allow(usuario).to receive(:idade).and_return(30)
puts usuario.idade  # 30

```

### **‚úÖ Expectativas (`expect`)**

```ruby
ruby
CopiarEditar
expect(usuario).to receive(:salvar)
usuario.salvar

```

‚úÖ **Quando usar?**

- Quando **n√£o queremos chamar depend√™ncias reais** (ex: API externa, banco de dados).

---

## **4Ô∏è‚É£ Cobertura de C√≥digo com SimpleCov**

SimpleCov **mede o quanto do c√≥digo est√° coberto por testes**.

üìå **Instala√ß√£o:**

```
gem install simplecov

```

üìå **Configura√ß√£o no `spec_helper.rb`:**

```ruby
ruby
CopiarEditar
require 'simplecov'
SimpleCov.start

```

üìå **Rodando os testes e gerando o relat√≥rio:**

```
rspec
open coverage/index.html

```

‚úÖ **Quando usar?**

- Para garantir que **testamos todas as partes cr√≠ticas do c√≥digo**.

---

## **5Ô∏è‚É£ Linters e Ferramentas de Qualidade**

### **‚úÖ RuboCop (Padr√£o de C√≥digo e Best Practices)**

üìå **Instala√ß√£o:**

```
gem install rubocop

```

üìå **Rodando:**

```
rubocop

```

üìå **Corrigindo automaticamente:**

```
rubocop -A

```

‚úÖ **Quando usar?**

- Para **manter o c√≥digo limpo e idiom√°tico**.

---

### **‚úÖ Reek (Detecta "Code Smells")**

üìå **Instala√ß√£o:**

```
gem install reek

```

üìå **Rodando:**

```
reek

```

‚úÖ **Quando usar?**

- Identificar **c√≥digo complexo e dif√≠cil de manter**.

---

### **‚úÖ Flay (Detecta C√≥digo Duplicado)**

üìå **Instala√ß√£o:**

```
gem install flay

```

üìå **Rodando:**

```
flay lib/

```

‚úÖ **Quando usar?**

- Para **reduzir c√≥digo repetitivo e melhorar manutenibilidade**.

---

### **‚úÖ Brakeman (Verifica√ß√£o de Seguran√ßa para Rails)**

üìå **Instala√ß√£o:**

```
gem install brakeman

```

üìå **Rodando:**

```
brakeman

```

‚úÖ **Quando usar?**

- Para **identificar vulnerabilidades de seguran√ßa no Rails**.

---

# **üìå Conclus√£o**

1. **Testes Automatizados**
    - `RSpec`: Testes unit√°rios e BDD.
    - `MiniTest`: Alternativa minimalista.
    - `Capybara`: Testes de interface.
2. **TDD e BDD**
    - TDD ‚Üí **Escreve testes antes do c√≥digo**.
    - BDD ‚Üí **Foca no comportamento esperado**.
3. **Mocking e Stubbing**
    - `double`: Criar mocks.
    - `allow`: Definir comportamento falso.
    - `expect`: Verificar chamadas esperadas.
4. **Cobertura de C√≥digo**
    - SimpleCov mede a **cobertura dos testes**.
5. **Ferramentas de Qualidade**
    - **RuboCop**: Corrige c√≥digo ruim.
    - **Reek**: Encontra c√≥digo com "cheiro ruim".
    - **Flay**: Detecta c√≥digo duplicado.
    - **Brakeman**: Seguran√ßa em Rails.

---

# **üìå 7. Gems e Ecossistema** üöÄ

O ecossistema Ruby √© fortemente impulsionado por **gems** ‚Äì bibliotecas reutiliz√°veis que adicionam funcionalidades ao c√≥digo.

---

## **1Ô∏è‚É£ Criando e Publicando Gems**

Ruby permite criar suas pr√≥prias gems e public√°-las no [RubyGems.org](https://rubygems.org/).

### **‚úÖ Criando uma Gem do Zero**

üìå **Gerando o esqueleto do projeto com `bundle gem`**

```
bundle gem minha_gem

```

üìå **Isso cria a estrutura:**

```
b
minha_gem/
‚îÇ‚îÄ‚îÄ lib/                 # C√≥digo principal
‚îÇ   ‚îî‚îÄ‚îÄ minha_gem.rb
‚îÇ‚îÄ‚îÄ minha_gem.gemspec    # Especifica√ß√µes da gem
‚îÇ‚îÄ‚îÄ Rakefile             # Tarefas autom√°ticas
‚îÇ‚îÄ‚îÄ README.md            # Documenta√ß√£o
‚îÇ‚îÄ‚îÄ Gemfile              # Depend√™ncias

```

---

### **‚úÖ Configurando o `.gemspec`**

O arquivo `.gemspec` define as configura√ß√µes da gem.

```ruby
ruby
CopiarEditar
Gem::Specification.new do |spec|
  spec.name          = "minha_gem"
  spec.version       = "0.1.0"
  spec.authors       = ["Seu Nome"]
  spec.summary       = "Uma gem incr√≠vel!"
  spec.files         = Dir["lib/**/*.rb"]
  spec.required_ruby_version = ">= 2.7"
  spec.add_dependency "faraday", "~> 2.0"
end

```

---

### **‚úÖ Construindo e Instalando a Gem Localmente**

```
gem build minha_gem.gemspec
gem install minha_gem-0.1.0.gem

```

---

### **‚úÖ Publicando no RubyGems**

üìå **Crie uma conta no [RubyGems](https://rubygems.org/)** e rode:

```
gem push minha_gem-0.1.0.gem

```

üöÄ Agora sua gem est√° publicada!

---

## **2Ô∏è‚É£ Gems Essenciais para um Desenvolvedor Ruby**

Aqui est√£o **gems essenciais** que um **senior Ruby developer** deve conhecer:

### **üîπ Pry (Debugging no Console Interativo)**

üìå **Instala√ß√£o:**

```
gem install pry

```

üìå **Uso:**

```ruby
ruby
CopiarEditar
require 'pry'
binding.pry  # Pausa a execu√ß√£o e abre um console interativo

```

‚úÖ **Quando usar?**

- Para **depura√ß√£o interativa** em c√≥digo Ruby.

---

### **üîπ Sidekiq (Processamento Ass√≠ncrono com Redis)**

üìå **Instala√ß√£o:**

```
gem install sidekiq

```

üìå **Exemplo de Job:**

```ruby
ruby
CopiarEditar
class MeuJob
  include Sidekiq::Worker

  def perform(nome)
    puts "Processando #{nome}"
  end
end

```

üìå **Execu√ß√£o do Job:**

```ruby
ruby
CopiarEditar
MeuJob.perform_async("Tarefa 1")

```

‚úÖ **Quando usar?**

- Para **tarefas em background**, como envio de e-mails e processamento de imagens.

---

### **üîπ Faraday (HTTP Requests Simples e Flex√≠veis)**

üìå **Instala√ß√£o:**

```
gem install faraday

```

üìå **Exemplo de Uso:**

```ruby
ruby
CopiarEditar
require 'faraday'

response = Faraday.get('https://jsonplaceholder.typicode.com/todos/1')
puts response.body

```

‚úÖ **Quando usar?**

- Para fazer **requisi√ß√µes HTTP de forma flex√≠vel**.

---

### **üîπ Dry-rb (Codebase Mais Modular e Funcional)**

O **Dry-rb** √© um conjunto de gems que ajuda a melhorar o design de c√≥digo Ruby.

üìå **Instala√ß√£o:**

```
gem install dry-struct

```

üìå **Exemplo de Uso (`dry-struct`)**

```ruby
ruby
CopiarEditar
require 'dry-struct'

class Usuario < Dry::Struct
  attribute :nome, Types::String
  attribute :idade, Types::Integer
end

u = Usuario.new(nome: "Jo√£o", idade: 30)
puts u.nome  # Jo√£o

```

‚úÖ **Quando usar?**

- Quando deseja um **c√≥digo mais estruturado e seguro**.

---

### **üîπ Sorbet (Tipagem Est√°tica no Ruby)**

üìå **Instala√ß√£o:**

```
gem install sorbet

```

üìå **Uso:**

```ruby
ruby
CopiarEditar
require 'sorbet-runtime'

class Calculadora
  extend T::Sig

  sig { params(a: Integer, b: Integer).returns(Integer) }
  def soma(a, b)
    a + b
  end
end

```

‚úÖ **Quando usar?**

- Para **tipagem est√°tica** e mais seguran√ßa no c√≥digo.

---

### **üîπ FactoryBot (Factories para Testes)**

üìå **Instala√ß√£o:**

```
gem install factory_bot

```

üìå **Exemplo de Factory:**

```ruby
ruby
CopiarEditar
FactoryBot.define do
  factory :usuario do
    nome { "Jo√£o" }
    email { "joao@example.com" }
  end
end

```

‚úÖ **Quando usar?**

- Para criar **dados de teste rapidamente** em specs.

---

### **üîπ Devise (Autentica√ß√£o R√°pida no Rails)**

üìå **Instala√ß√£o:**

```
gem install devise

```

üìå **Gerando a configura√ß√£o:**

```
rails generate devise:install

```

‚úÖ **Quando usar?**

- Para **autentica√ß√£o de usu√°rios** em aplica√ß√µes Rails.

---

## **3Ô∏è‚É£ Gerenciamento de Depend√™ncias (Bundler, Gemfile.lock)**

O **Bundler** gerencia gems e suas vers√µes em projetos Ruby.

---

### **‚úÖ Instalando o Bundler**

```
gem install bundler

```

üìå **Exemplo de `Gemfile`:**

```ruby
ruby
CopiarEditar
source "https://rubygems.org"

gem "rails", "~> 7.0"
gem "sidekiq"
gem "pry"

```

üìå **Instalando as depend√™ncias:**

```
bundle install

```

üìå **Atualizando gems:**

```
bundle update

```

üìå **Gerando um `Gemfile.lock`:**

```
bundle lock

```

‚úÖ **Quando usar?**

- Sempre que precisar gerenciar **depend√™ncias em projetos Ruby**.

---

# **üìå Conclus√£o**

1. **Criando e Publicando Gems**
    - `bundle gem` ‚Üí Gera estrutura b√°sica.
    - `gem build` ‚Üí Compila a gem.
    - `gem push` ‚Üí Publica no RubyGems.
2. **Gems Essenciais**
    - **Depura√ß√£o:** `pry`
    - **Background Jobs:** `sidekiq`
    - **HTTP Requests:** `faraday`
    - **Tipagem Est√°tica:** `sorbet`
    - **Factories:** `factory_bot`
    - **Autentica√ß√£o:** `devise`
3. **Gerenciamento de Depend√™ncias**
    - `Bundler` ‚Üí Instala e gerencia gems.
    - `Gemfile.lock` ‚Üí Garante que vers√µes sejam fixas.

---

# **üìå 8. Ferramentas e Boas Pr√°ticas** üöÄ

Manter **c√≥digo limpo, organizado e eficiente** √© essencial para um **Senior Ruby Developer**.

---

## **1Ô∏è‚É£ Code Style Guide do Ruby e Rails**

### **‚úÖ Estilo de C√≥digo Ruby**

O **Ruby Style Guide** (https://rubystyle.guide/) define as boas pr√°ticas do c√≥digo Ruby.

üìå **Principais Regras:**

‚úÖ Use **2 espa√ßos** para identa√ß√£o, nunca tab.

‚úÖ Use `snake_case` para nomes de m√©todos e vari√°veis.

‚úÖ Use `CamelCase` para classes e m√≥dulos.

‚úÖ Evite `if` inline para c√≥digo complexo.

```ruby
ruby
CopiarEditar
# Certo ‚úÖ
class Usuario
  def initialize(nome)
    @nome = nome
  end
end

# Errado ‚ùå
class usuario
  def Initialize(Nome)
    @Nome = Nome
  end
end

```

---

### **‚úÖ Estilo de C√≥digo Rails**

üìå **O Rails tem seu pr√≥prio guia**:

https://rails.rubystyle.guide/

‚úÖ **Principais pr√°ticas:**

- **Evite callbacks complexos (`before_save`, `after_create`)**.
- **Prefira scopes sobre m√©todos de classe**.
- **Use `find_each` para grandes quantidades de registros**.

```ruby
ruby
CopiarEditar
# Certo ‚úÖ
class Usuario < ApplicationRecord
  scope :ativos, -> { where(ativo: true) }
end

# Errado ‚ùå
class Usuario < ApplicationRecord
  def self.ativos
    where(ativo: true)
  end
end

```

---

## **2Ô∏è‚É£ Estruturas de Logs (Logger, Lograge, Structured Logging)**

### **‚úÖ Logger (Padr√£o do Ruby)**

O `Logger` j√° vem embutido no Ruby e Rails.

üìå **Uso B√°sico:**

```ruby
ruby
CopiarEditar
require 'logger'

logger = Logger.new(STDOUT)
logger.info("Isso √© uma informa√ß√£o")
logger.warn("Isso √© um aviso")
logger.error("Isso √© um erro!")

```

üìå **Log no Rails (`config/application.rb`)**

```ruby
ruby
CopiarEditar
config.logger = Logger.new(STDOUT)
config.log_level = :info  # :debug, :warn, :error, :fatal

```

‚úÖ **Boa pr√°tica:**

- Use `Logger` para rastrear erros sem expor informa√ß√µes sens√≠veis.

---

### **‚úÖ Lograge (Logs Estruturados no Rails)**

Por padr√£o, os logs do Rails s√£o verbosos. **Lograge** os torna mais leg√≠veis.

üìå **Instala√ß√£o:**

```
gem install lograge

```

üìå **Configura√ß√£o no `config/environments/production.rb`:**

```ruby
ruby
CopiarEditar
config.lograge.enabled = true
config.lograge.formatter = ->(data) { data.to_json }

```

‚úÖ **Quando usar?**

- Para **formatar logs de forma estruturada** e melhorar a observabilidade.

---

### **‚úÖ Structured Logging (Logs em JSON para Monitoramento)**

üìå **Exemplo com `lograge` e `ActiveSupport::Logger`**

```ruby
ruby
CopiarEditar
logger = ActiveSupport::Logger.new(STDOUT)
logger.formatter = ->(severity, time, progname, msg) { { level: severity, time: time, message: msg }.to_json }

```

‚úÖ **Quando usar?**

- Quando precisa de logs **estruturados para monitoramento** em ferramentas como **ELK, Datadog, Splunk**.

---

## **3Ô∏è‚É£ Monitoramento e Debugging (byebug, pry, rack-mini-profiler)**

### **‚úÖ Byebug (Debugging Interativo para Ruby)**

üìå **Instala√ß√£o:**

```
gem install byebug

```

üìå **Uso:**

```ruby
ruby
CopiarEditar
require 'byebug'

def soma(a, b)
  byebug  # Pausa a execu√ß√£o aqui
  a + b
end

soma(2, 3)

```

‚úÖ **Quando usar?**

- Para **pausar a execu√ß√£o** e inspecionar vari√°veis no terminal.

---

### **‚úÖ Pry (Console Interativo Mais Poderoso que IRB)**

üìå **Instala√ß√£o:**

```
gem install pry

```

üìå **Substituir o IRB por Pry:**

```
pry

```

üìå **Adicionar um `binding.pry` no c√≥digo:**

```ruby
ruby
CopiarEditar
require 'pry'

def saudacao(nome)
  binding.pry  # Pausa aqui e entra no console interativo
  "Ol√°, #{nome}!"
end

saudacao("Jo√£o")

```

‚úÖ **Quando usar?**

- Para **depurar e explorar objetos dinamicamente**.

---

### **‚úÖ rack-mini-profiler (Monitoramento de Performance no Rails)**

üìå **Instala√ß√£o:**

```
gem install rack-mini-profiler

```

üìå **Configura√ß√£o no `config/application.rb`:**

```ruby
ruby
CopiarEditar
Rack::MiniProfiler.config.auto_inject = true

```

üöÄ **Agora voc√™ v√™ um painel de performance no topo do app Rails!**

‚úÖ **Quando usar?**

- Para **monitorar consultas SQL lentas, tempo de resposta e gargalos**.

---

## **4Ô∏è‚É£ Ruby Versions e Gerenciadores (rbenv, rvm)**

### **‚úÖ rbenv (Gerenciador de Vers√£o Ruby mais Leve e R√°pido)**

üìå **Instala√ß√£o no Linux/macOS:**

```
brew install rbenv
rbenv install 3.2.2
rbenv global 3.2.2

```

üìå **Verificando a vers√£o:**

```
ruby -v

```

‚úÖ **Quando usar?**

- Quando quer um gerenciador **leve e sem modificar shell scripts**.

---

### **‚úÖ RVM (Gerenciador de Ruby Completo)**

üìå **Instala√ß√£o:**

```
\curl -sSL https://get.rvm.io | bash -s stable

```

üìå **Instalando Ruby com RVM:**

```
rvm install 3.2.2
rvm use 3.2.2 --default

```

‚úÖ **Quando usar?**

- Quando precisa gerenciar **m√∫ltiplas vers√µes e configura√ß√µes do Ruby**.

---

# **üìå Conclus√£o**

1. **Code Style Guide**
    - Use **2 espa√ßos** para identa√ß√£o.
    - Prefira `snake_case` para m√©todos e `CamelCase` para classes.
    - Rails: **evite callbacks complexos** e prefira **scopes**.
2. **Logging**
    - **Logger** para logs b√°sicos.
    - **Lograge** para logs mais limpos no Rails.
    - **Structured Logging** para logs em JSON.
3. **Debugging e Monitoramento**
    - **Byebug** para pausas interativas.
    - **Pry** para explora√ß√£o din√¢mica.
    - **rack-mini-profiler** para monitoramento de performance.
4. **Gerenciadores de Ruby**
    - **rbenv** (mais leve, recomendado).
    - **RVM** (mais completo, √∫til para m√∫ltiplas vers√µes).

---